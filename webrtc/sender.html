<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Sender (Answerer, iPhone)</title>
  <link rel="icon" href="data:,">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    video { width: 100%; max-height: 60vh; background: #000; border-radius: 8px; }
    textarea { width: 100%; height: 140px; }
    button { padding: 10px 14px; margin: 6px 4px 6px 0; }
    .row { margin: 12px 0; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .small { font-size: 12px; color: #666; }
    label { display:block; margin-bottom: 6px; }
    select { padding: 8px; }
    .status { margin-left: 6px; font-weight: 600; }
    .notice { background:#e7f3ff; border:1px solid #b6e0ff; padding:8px 10px; border-radius:6px; font-size:13px; }
  </style>
</head>
<body>
  <h1>Sender (Answerer, iPhone)</h1>

  <div class="notice">
    Keep this page in the foreground and the screen unlocked. On iPhone, the camera stops if the device locks or you switch apps.
  </div>

  <div class="row">
    <label>Camera:</label>
    <select id="cameraFacing">
      <option value="environment" selected>Back camera</option>
      <option value="user">Front camera</option>
    </select>
  </div>

  <div class="row">
    <button id="start">Start camera & mic</button>
    <span class="small">Requires HTTPS.</span>
    <span class="status" id="pcState">Idle</span>
  </div>

  <video id="local" playsinline muted autoplay></video>

  <div class="row">
    <label for="offer" class="small">Paste Offer (from laptop):</label>
    <textarea id="offer" placeholder='{"type":"offer","sdp":"..."}'></textarea>
  </div>

  <div class="row">
    <button id="acceptOffer" disabled>Accept Offer & Create Answer</button>
    <button id="copyAnswer" disabled>Copy Answer</button>
  </div>

  <textarea id="answer" placeholder="Answer will appear here" readonly></textarea>

  <script>
    let pc = null, localStream = null, wakeLock = null;
    const startBtn = document.getElementById('start');
    const acceptOfferBtn = document.getElementById('acceptOffer');
    const copyAnswerBtn = document.getElementById('copyAnswer');
    const offerTA = document.getElementById('offer');
    const answerTA = document.getElementById('answer');
    const localVideo = document.getElementById('local');
    const pcState = document.getElementById('pcState');
    const cameraFacing = document.getElementById('cameraFacing');

    const setStatus = (s) => pcState.textContent = s;

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {});
          document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
              try { wakeLock = await navigator.wakeLock.request('screen'); } catch {}
            }
          });
        }
      } catch {}
    }

    function createPC() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }],
        sdpSemantics: 'unified-plan',
        bundlePolicy: 'max-bundle'
      });
      pc.oniceconnectionstatechange = () => setStatus(pc.iceConnectionState);
      pc.onconnectionstatechange = () => setStatus(pc.connectionState);
    }

    async function getMedia() {
      const facingMode = cameraFacing.value;
      return navigator.mediaDevices.getUserMedia({
        video: {
          facingMode,
          width: { ideal: 1280 }, height: { ideal: 720 },
          frameRate: { ideal: 30, max: 30 }
        },
        audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }
      });
    }

    async function startCapture() {
      localStream = await getMedia();
      localVideo.srcObject = localStream;

      // Reacquire tracks if they end (e.g., device sleeps)
      localStream.getTracks().forEach(track => {
        track.onended = async () => {
          try {
            const newStream = await getMedia();
            const senders = pc ? pc.getSenders() : [];
            for (const newTrack of newStream.getTracks()) {
              const sender = senders.find(s => s.track && s.track.kind === newTrack.kind);
              if (sender) await sender.replaceTrack(newTrack);
              else if (pc) pc.addTrack(newTrack, newStream);
            }
            localStream = newStream;
            localVideo.srcObject = localStream;
          } catch (e) {
            console.warn('Reacquire media failed:', e);
          }
        };
      });

      acceptOfferBtn.disabled = false;
      requestWakeLock();
    }

    const waitForIceGatheringComplete = (pc) => {
      if (pc.iceGatheringState === 'complete') return Promise.resolve();
      return new Promise(resolve => {
        const check = () => {
          if (pc.iceGatheringState === 'complete') {
            pc.removeEventListener('icegatheringstatechange', check);
            resolve();
          }
        };
        pc.addEventListener('icegatheringstatechange', check);
      });
    };

    async function acceptOfferAndAnswer() {
      const val = offerTA.value.trim();
      if (!val) return alert('Paste the Offer JSON first.');
      if (!pc) createPC();

      let remote;
      try {
        remote = JSON.parse(val);
        if (remote.type !== 'offer') throw new Error('Pasted JSON is not an SDP offer');
        await pc.setRemoteDescription(remote);
      } catch (e) {
        console.error('setRemoteDescription(offer) failed', e);
        alert('setRemoteDescription (offer) failed: ' + (e?.message || e));
        return;
      }

      // Attach tracks so the answer is sendonly
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      await waitForIceGatheringComplete(pc);

      answerTA.value = JSON.stringify(pc.localDescription);
      copyAnswerBtn.disabled = false;
    }

    startBtn.onclick = async () => {
      startBtn.disabled = true;
      try { await startCapture(); }
      catch (e) {
        startBtn.disabled = false;
        alert('Failed to start camera/mic: ' + e.message);
      }
    };

    acceptOfferBtn.onclick = acceptOfferAndAnswer;

    copyAnswerBtn.onclick = async () => {
      try { await navigator.clipboard.writeText(answerTA.value); }
      catch { answerTA.select(); document.execCommand('copy'); }
    };
  </script>
</body>
</html>
