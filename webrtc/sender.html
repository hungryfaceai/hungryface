<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Sender (iPhone) – Baby Monitor</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; padding: 0; height: 100%;
      background: #000; color: #bbb; font-family: -apple-system, system-ui, sans-serif;
      touch-action: manipulation;
    }
    /* Container */
    .wrap {
      min-height: 100%; display: flex; flex-direction: column;
      align-items: center; justify-content: center; gap: 18px; padding: 16px;
    }
    /* Controls card */
    .card {
      width: 100%; max-width: 520px; background: #0a0a0a; border-radius: 14px;
      padding: 18px; box-sizing: border-box; border: 1px solid #141414;
    }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin: 10px 0; }
    label.switch { display: flex; align-items: center; gap: 10px; font-size: 16px; }
    input[type="checkbox"] { width: 22px; height: 22px; }
    input[type="text"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #222; background:#0a0a0a; color:#ddd; }
    button {
      width: 100%; padding: 14px 16px; border-radius: 12px; border: 0;
      background: #2a2a2a; color: #fff; font-size: 17px; font-weight: 600;
    }
    button:active { transform: scale(0.99); }
    .hint { opacity: .7; font-size: 13px; }

    /* Hidden video element just to keep camera running */
    video { position: fixed; left: -9999px; top: -9999px; width:1px; height:1px; }

    /* Blackout states */
    .blackout { background: #000; }
    .peek { background: #121212; } /* “more luminosity” but still black */

    /* Overlay status in blackout/peek */
    .overlay {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      pointer-events: none;
    }
    .blackout .overlay, .peek .overlay { display: flex; }
    .status {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      color: #ddd; font-size: 14px; padding: 10px 14px; border-radius: 12px;
    }
    .taparea {
      position: fixed; inset: 0; display: none; /* enabled once streaming */
    }
    .streaming .taparea { display: block; }
  </style>
</head>
<body class="blackout">
  <div class="wrap" id="ui">
    <h2 style="margin:0 0 6px 0;">iPhone Sender</h2>

    <div class="card">
      <div class="row">
        <label class="switch">
          <input id="videoOn" type="checkbox" checked>
          <span>Video ON</span>
        </label>
        <label class="switch">
          <input id="audioOn" type="checkbox" checked>
          <span>Audio ON</span>
        </label>
      </div>

      <div class="row">
        <input id="room" type="text" placeholder="Room (e.g., baby1)" value="baby1" autocomplete="off">
      </div>

      <div class="row">
        <button id="startBtn">Start streaming</button>
      </div>

      <p class="hint">The screen will go fully black. Tap anywhere to “peek” (slightly brighter black); tap again to return to full blackout.</p>
      <p class="hint">Requires the receiver page to be open on the laptop and in the same room.</p>
    </div>
  </div>

  <!-- Touch layer for blackout/peek -->
  <div class="taparea" id="tap"></div>
  <div class="overlay"><div class="status" id="status">Idle</div></div>

  <!-- Hidden video to keep the capture alive -->
  <video id="local" playsinline autoplay muted></video>

  <script>
    // ===== Elements
    const $ = id => document.getElementById(id);
    const ui = $('ui');
    const startBtn = $('startBtn');
    const roomInput = $('room');
    const videoOn = $('videoOn');
    const audioOn = $('audioOn');
    const localVideo = $('local');
    const statusEl = $('status');
    const tap = $('tap');

    // ===== State
    let pc = null, ws = null, localStream = null;
    let wakeLock = null;
    let room = new URLSearchParams(location.search).get('room') || roomInput.value || 'baby1';

    // ===== Helpers
    const setStatus = (t) => { statusEl.textContent = t; };

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible') {
              try { wakeLock = await navigator.wakeLock.request('screen'); } catch {}
            }
          });
        }
      } catch {}
    }

    async function getMedia() {
      const wantVideo = videoOn.checked;
      const wantAudio = audioOn.checked;

      /** Build constraints only for requested kinds */
      const constraints = {};
      if (wantVideo) {
        constraints.video = {
          facingMode: 'environment',
          width: { ideal: 1280 }, height: { ideal: 720 },
          frameRate: { ideal: 30, max: 30 }
        };
      } else {
        constraints.video = false;
      }
      constraints.audio = wantAudio ? {
        echoCancellation: true, noiseSuppression: true, autoGainControl: true
      } : false;

      if (!wantVideo && !wantAudio) throw new Error('Both video and audio are OFF.');

      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      return stream;
    }

    function createPC() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }],
        sdpSemantics: 'unified-plan',
        bundlePolicy: 'max-bundle'
      });
      pc.oniceconnectionstatechange = () => setStatus('ICE: ' + pc.iceConnectionState);
      pc.onconnectionstatechange = () => setStatus('Conn: ' + pc.connectionState);
      pc.onicecandidate = (e) => {
        if (e.candidate) send({ type: 'candidate', candidate: e.candidate });
      };
    }

    function connectWS() {
      return new Promise((resolve, reject) => {
        try {
          // Render (and local) friendly: same host, WSS in prod.
          const wsURL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host;
          ws = new WebSocket(wsURL);
          ws.onopen = () => {
            send({ type: 'join', room });
            resolve();
          };
          ws.onmessage = onSignal;
          ws.onerror = err => reject(err);
          ws.onclose = () => { /* no-op; receiver can reconnect */ };
        } catch (e) { reject(e); }
      });
    }

    function send(obj) {
      try { ws && ws.readyState === WebSocket.OPEN && ws.send(JSON.stringify(obj)); } catch {}
    }

    async function onSignal(evt) {
      let msg = null;
      try { msg = JSON.parse(evt.data); } catch { return; }

      if (msg.type === 'offer') {
        // Receiver sent an SDP offer → we answer.
        await pc.setRemoteDescription(msg);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        send(pc.localDescription);
      } else if (msg.type === 'candidate' && msg.candidate) {
        try { await pc.addIceCandidate(msg.candidate); } catch {}
      }
    }

    async function startStreaming() {
      try {
        startBtn.disabled = true;
        room = roomInput.value.trim() || room;
        setStatus('Starting camera…');

        // 1) Capture
        localStream = await getMedia();
        localVideo.srcObject = localStream;

        // 2) PeerConnection
        createPC();
        for (const track of localStream.getTracks()) {
          pc.addTrack(track, localStream);
        }

        // 3) Signaling
        setStatus('Connecting…');
        await connectWS();
        setStatus('Waiting for offer…');

        // Enter blackout/monitor mode
        document.body.classList.add('blackout', 'streaming');
        ui.style.display = 'none';   // hide UI
        await requestWakeLock();

        // Reacquire tracks if they end (rare on iOS if app backgrounded)
        localStream.getTracks().forEach(track => {
          track.onended = async () => {
            try {
              const newStream = await getMedia();
              const senders = pc.getSenders();
              for (const newTrack of newStream.getTracks()) {
                const sender = senders.find(s => s.track && s.track.kind === newTrack.kind);
                if (sender) await sender.replaceTrack(newTrack);
                else pc.addTrack(newTrack, newStream);
              }
              localStream = newStream;
              localVideo.srcObject = localStream;
            } catch (e) {}
          };
        });

      } catch (e) {
        alert(e.message || e);
        startBtn.disabled = false;
        setStatus('Idle');
      }
    }

    // ===== UI bindings
    startBtn.addEventListener('click', startStreaming);

    // Tap anywhere to toggle between full blackout and “peek”
    let peekOn = false;
    const togglePeek = () => {
      peekOn = !peekOn;
      document.body.classList.toggle('peek', peekOn);
      document.body.classList.toggle('blackout', !peekOn);
    };
    tap.addEventListener('click', togglePeek);
    // Also allow a quick tap anywhere (fallback) once streaming
    document.body.addEventListener('click', (e) => {
      if (!document.body.classList.contains('streaming')) return;
      if (e.target === tap) return; // already handled
      togglePeek();
    });

    // Keep room field in sync with ?room=
    roomInput.addEventListener('change', () => {
      const url = new URL(location.href);
      url.searchParams.set('room', roomInput.value.trim() || 'baby1');
      history.replaceState({}, '', url);
    });

    // Default to blackout before starting
    document.body.classList.add('blackout');
  </script>
</body>
</html>
