<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebRTC Receiver (Offerer) + MediaPipe Pose</title>
  <link rel="icon" href="data:,">
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; max-width: 980px; margin: 0 auto; }
    video, canvas { width: 100%; max-height: 70vh; background: #000; border-radius: 8px; display: block; }
    textarea { width: 100%; height: 140px; }
    button { padding: 10px 14px; margin: 6px 4px 6px 0; }
    .row { margin: 12px 0; display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .status { font-weight: 600; }
    .overwrap { position: relative; }
    #overlay { position: absolute; left:0; top:0; pointer-events: none; }
    .small { font-size: 12px; color: #666; }
    label.small { user-select: none; }
  </style>
</head>
<body>
  <div class="grid">
    <h1>Laptop (Offerer) + Pose</h1>

    <div class="row">
      <button id="createOffer">Create Offer</button>
      <button id="copyOffer" disabled>Copy Offer</button>
      <label class="small"><input type="checkbox" id="wantAudio" checked> Offer to receive audio</label>
      <button id="reset">Reset</button>
      <span class="status" id="pcState">Idle</span>
    </div>

    <textarea id="offer" placeholder="Offer will appear here" readonly></textarea>

    <div class="row">
      <label for="answer" class="small">Paste Answer (from iPhone):</label>
      <textarea id="answer" placeholder='{"type":"answer","sdp":"..."}'></textarea>
      <button id="acceptAnswer">Accept Answer</button>
    </div>

    <div class="row">
      <button id="enableAudio" disabled>Enable Audio (if blocked)</button>
      <span class="small">Browsers may block autoplay with sound until you click.</span>
    </div>

    <div class="overwrap">
      <video id="remote" playsinline autoplay></video>
      <canvas id="overlay"></canvas>
    </div>

    <div class="row small" id="perf"></div>
  </div>

  <script type="module">
    import {
      FilesetResolver,
      PoseLandmarker,
      DrawingUtils
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

    const createOfferBtn = document.getElementById('createOffer');
    const copyOfferBtn = document.getElementById('copyOffer');
    const acceptAnswerBtn = document.getElementById('acceptAnswer');
    const offerTA = document.getElementById('offer');
    const answerTA = document.getElementById('answer');
    const pcState = document.getElementById('pcState');
    const wantAudio = document.getElementById('wantAudio');
    const resetBtn = document.getElementById('reset');
    const video = document.getElementById('remote');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const enableAudioBtn = document.getElementById('enableAudio');
    const perf = document.getElementById('perf');

    let pc = null;
    let landmarker = null;
    let drawingUtils = null;
    let lastT = performance.now();
    let inferenceRunning = false;

    function setStatus(s) { pcState.textContent = s; }

    function waitForIceGatheringComplete(pc) {
      if (pc.iceGatheringState === 'complete') return Promise.resolve();
      return new Promise(resolve => {
        function check() {
          if (pc.iceGatheringState === 'complete') {
            pc.removeEventListener('icegatheringstatechange', check);
            resolve();
          }
        }
        pc.addEventListener('icegatheringstatechange', check);
      });
    }

    function resizeOverlayToVideo() {
      const dpr = window.devicePixelRatio || 1;
      const w = video.videoWidth | 0;
      const h = video.videoHeight | 0;
      if (!w || !h) return;
      overlay.style.width = w + "px";
      overlay.style.height = h + "px";
      overlay.width = Math.floor(w * dpr);
      overlay.height = Math.floor(h * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    async function initPose() {
      if (landmarker) return;
      const fileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );
      landmarker = await PoseLandmarker.createFromOptions(fileset, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/latest/pose_landmarker_lite.task",
          delegate: "GPU"
        },
        runningMode: "video",
        numPoses: 1,
        minPoseDetectionConfidence: 0.4,
        minPosePresenceConfidence: 0.4,
        minTrackingConfidence: 0.4
      });
      drawingUtils = new DrawingUtils(ctx);
    }

    function startInferenceLoop() {
      if (inferenceRunning) return;
      inferenceRunning = true;
      const useVFC = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;

      const step = async (tMs) => {
        if (!landmarker || video.readyState < 2) {
          if (useVFC) video.requestVideoFrameCallback((_now, meta) => step(meta.mediaTime * 1000));
          else requestAnimationFrame(() => step(performance.now()));
          return;
        }

        const results = await landmarker.detectForVideo(video, tMs);

        const now = performance.now();
        const dt = now - lastT; lastT = now;
        const fps = 1000 / dt;
        perf.textContent = `Inference ~ ${fps.toFixed(1)} FPS`;

        resizeOverlayToVideo();
        ctx.clearRect(0, 0, overlay.width, overlay.height);
        if (results.landmarks) for (const lm of results.landmarks) drawingUtils.drawLandmarks(lm);

        if (useVFC) video.requestVideoFrameCallback((_now, meta) => step(meta.mediaTime * 1000));
        else requestAnimationFrame(() => step(performance.now()));
      };

      const kickoff = () => {
        resizeOverlayToVideo();
        if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
          video.requestVideoFrameCallback((_now, meta) => step(meta.mediaTime * 1000));
        } else {
          requestAnimationFrame(() => step(performance.now()));
        }
      };

      if (video.readyState >= 2) kickoff();
      else video.onloadedmetadata = kickoff;
    }

    createOfferBtn.onclick = async () => {
      createOfferBtn.disabled = true;
      try {
        pc = new RTCPeerConnection({
          iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }],
          sdpSemantics: 'unified-plan',
          bundlePolicy: 'max-bundle'
        });

        // Receive media from iPhone
        pc.addTransceiver('video', { direction: 'recvonly' });
        if (wantAudio.checked) pc.addTransceiver('audio', { direction: 'recvonly' });

        pc.oniceconnectionstatechange = () => setStatus(pc.iceConnectionState);
        pc.onconnectionstatechange = () => setStatus(pc.connectionState);
        pc.ontrack = (e) => {
          video.srcObject = e.streams[0];
          enableAudioBtn.disabled = false;
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await waitForIceGatheringComplete(pc);

        offerTA.value = JSON.stringify(pc.localDescription);
        copyOfferBtn.disabled = false;
      } catch (e) {
        console.error('Create offer failed', e);
        alert('Create offer failed: ' + (e?.message || e));
        createOfferBtn.disabled = false;
      }
    };

    copyOfferBtn.onclick = async () => {
      try { await navigator.clipboard.writeText(offerTA.value); }
      catch { offerTA.select(); document.execCommand('copy'); }
    };

    acceptAnswerBtn.onclick = async () => {
      const val = answerTA.value.trim();
      if (!val) return alert('Paste the Answer JSON first.');
      try {
        const desc = JSON.parse(val);
        if (desc.type !== 'answer') throw new Error('Pasted JSON is not an SDP answer');
        if (pc?.signalingState !== 'have-local-offer') {
          throw new Error('Unexpected signalingState: ' + (pc?.signalingState || 'none') + ' (expected have-local-offer)');
        }
        await pc.setRemoteDescription(desc);
        await initPose();
        startInferenceLoop();
      } catch (e) {
        console.error('Accept answer failed', e, { local: pc?.localDescription?.type, state: pc?.signalingState });
        alert('Accept answer failed: ' + (e?.message || e));
      }
    };

    enableAudioBtn.onclick = async () => {
      try { await video.play(); enableAudioBtn.disabled = true; }
      catch { alert('Autoplay blocked, click the page and try again.'); }
    };

    resetBtn.onclick = () => {
      try { pc?.getSenders().forEach(s => s.track && s.track.stop()); } catch {}
      try { pc?.close(); } catch {}
      pc = null;
      video.srcObject = null;
      overlay.width = overlay.height = 0;
      offerTA.value = '';
      answerTA.value = '';
      copyOfferBtn.disabled = true;
      createOfferBtn.disabled = false;
      setStatus('Idle');
      inferenceRunning = false;
      // keep landmarker loaded for reuse
    };
  </script>
</body>
</html>
