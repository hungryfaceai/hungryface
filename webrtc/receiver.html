<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Receiver – Baby Monitor</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin: 0; padding: 0; height: 100%; background: #000; color: #bbb; font-family: -apple-system, system-ui, sans-serif; }
    video { width: 100%; height: 100%; object-fit: cover; background: #000; }
    .overlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.5); z-index: 2; pointer-events: none; }
    .status { background: rgba(0,0,0,0.6); color: #fff; padding: 10px 16px; border-radius: 12px; font-size: 15px; }
  </style>
</head>
<body>
  <video id="remote" playsinline autoplay></video>
  <div class="overlay" id="overlay"><div class="status" id="status">Connecting…</div></div>

  <script>
    // --- Config: Render signaling
    const WS_ENDPOINT = "wss://hungryface.onrender.com/ws";

    const $ = id => document.getElementById(id);
    const remoteVideo = $('remote'), overlay = $('overlay'), statusEl = $('status');
    const setStatus = t => statusEl.textContent = t;

    let pc = null, ws = null;
    const room = new URLSearchParams(location.search).get('room') || 'baby1';

    function createPC() {
      pc = new RTCPeerConnection({ iceServers: [{ urls: ['stun:stun.l.google.com:19302'] }] });
      pc.oniceconnectionstatechange = () => setStatus('ICE: ' + pc.iceConnectionState);
      pc.onconnectionstatechange = () => setStatus('Conn: ' + pc.connectionState);
      pc.onicecandidate = (e) => { if (e.candidate) send({ type: 'candidate', candidate: e.candidate }); };
      pc.ontrack = (e) => {
        if (remoteVideo.srcObject !== e.streams[0]) {
          remoteVideo.srcObject = e.streams[0];
          overlay.style.display = 'none';
        }
      };
    }

    function connectWS() {
      return new Promise((resolve, reject) => {
        const url = `${WS_ENDPOINT}?room=${encodeURIComponent(room)}`;
        ws = new WebSocket(url);
        ws.onopen = () => { send({ type: 'join', room }); resolve(); };
        ws.onmessage = onSignal;
        ws.onerror = reject;
      });
    }
    function send(obj){ try{ ws && ws.readyState===WebSocket.OPEN && ws.send(JSON.stringify(obj)); }catch{} }

    async function onSignal(evt) {
      let msg; try { msg = JSON.parse(evt.data); } catch { return; }
      if (msg.type === 'answer') {
        await pc.setRemoteDescription(msg);
      } else if (msg.type === 'candidate' && msg.candidate) {
        try { await pc.addIceCandidate(msg.candidate); } catch {}
      }
    }

    async function start() {
      setStatus('Creating connection…'); createPC();
      setStatus('Connecting to signaling…'); await connectWS();

      // Receiver is offerer (recvonly)
      setStatus('Creating offer…');
      const offer = await pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
      await pc.setLocalDescription(offer);
      send(pc.localDescription);

      setStatus('Waiting for answer…');
    }

    start().catch(e => setStatus('Error: ' + (e.message || e)));
  </script>
</body>
</html>
