<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Baby Monitor – Sender</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0; height: 100%;
      background: #000; color: #ccc; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif;
      touch-action: manipulation;
    }
    #ui { min-height: 100%; display: flex; align-items: center; justify-content: center; padding: 20px; }
    .card {
      width: 100%; max-width: 520px;
      background: #0b0b0b; border: 1px solid #141414; border-radius: 14px;
      padding: 18px; box-sizing: border-box;
    }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin: 10px 0; }
    label.switch { display: flex; align-items: center; gap: 10px; font-size: 16px; }
    input[type="checkbox"] { width: 22px; height: 22px; }
    input[type="text"], select, input[type="number"] {
      width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #222; background:#0b0b0b; color:#ddd;
      -moz-appearance:textfield;
    }
    #cameraSel { font-size: 18px; padding: 14px 16px; height: 52px; border-radius: 12px; }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin_button { -webkit-appearance: none; margin: 0; }
    button {
      width: 100%; padding: 14px 16px; border-radius: 12px; border: 0;
      background: #2a2a2a; color: #fff; font-size: 17px; font-weight: 600;
    }
    button:active { transform: scale(0.99); }
    video#local {
      display: none;
      position: fixed; inset: 0;
      width: 100vw; height: 100vh;
      object-fit: cover; background: #000; z-index: 1;
    }
    body.previewing video#local { display: block; }
    body.blackout { background: #000; }
    body.streaming.ui-visible .overlay { display: none !important; }
    .overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; pointer-events: none; z-index: 2; }
    body.streaming .overlay, body.previewing .overlay { display: flex; }
    .status {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: #ddd; font-size: 14px; padding: 10px 14px; border-radius: 12px;
      text-align: center; white-space: pre-line;
    }
    #tap { position: fixed; inset: 0; display: none; z-index: 3; }
    body.streaming:not(.ui-visible) #tap { display: block; }
    body.streaming:not(.ui-visible) #ui { display: none; }
  </style>
</head>
<body class="blackout">
  <div id="ui">
    <div class="card">
      <h2 style="margin:0 0 8px 0;">Camera Sender</h2>

      <div class="row">
        <label class="switch">
          <input id="videoOn" type="checkbox" checked>
          <span>Video ON</span>
        </label>
        <label class="switch">
          <input id="audioOn" type="checkbox" checked>
          <span>Audio ON</span>
        </label>
      </div>

      <div class="row">
        <select id="cameraSel" aria-label="Camera">
          <option value="environment" selected>Back camera</option>
          <option value="user">Front camera</option>
        </select>
      </div>

      <div class="row">
        <input id="room" type="text" placeholder="Room (e.g., Baby)" value="Baby" autocomplete="off">
      </div>

      <div class="row">
        <input id="previewMins" type="number" min="0" step="1" value="1" aria-label="Preview minutes">
        <span style="opacity:.7;font-size:13px">Preview minutes</span>
      </div>

      <div class="row">
        <button id="startBtn">Start streaming</button>
      </div>
    </div>
  </div>

  <div id="tap" aria-hidden="true"></div>
  <div class="overlay"><div class="status" id="status">Idle</div></div>
  <video id="local" playsinline autoplay muted></video>

  <script>
    const WS_ENDPOINT = "wss://signaling-server-f5gu.onrender.com/ws";
    const UI_AUTOHIDE_MS = 10000;

    const videoOn   = document.getElementById('videoOn');
    const audioOn   = document.getElementById('audioOn');
    const cameraSel = document.getElementById('cameraSel');
    const roomInput = document.getElementById('room');
    const previewMinsInput = document.getElementById('previewMins');
    const startBtn  = document.getElementById('startBtn');
    const localVideo= document.getElementById('local');
    const statusEl  = document.getElementById('status');

    let ws = null, myId = null;
    let localStream = null;
    let started = false;
    let hideUITimer = null;
    let previewTimer = null, previewTicker = null, previewEnd = 0;

    // peerId -> { pc, remoteDescriptionSet, candidateQueue: [], lastOfferSdp }
    const peers = new Map();

    const setStatus = (t) => { statusEl.textContent = t; console.log('[STATUS]', t); };

    function currentRoom() {
      const r = (roomInput.value || 'Baby').trim();
      try { const u = new URL(location.href); u.searchParams.set('room', r); history.replaceState({}, '', u); } catch {}
      return r;
    }

    // --- Media ---
    async function getMedia() {
      const wantVideo = videoOn.checked;
      const wantAudio = audioOn.checked;
      if (!wantVideo && !wantAudio) throw new Error('Both video and audio are OFF.');

      const facing = cameraSel.value || 'environment';
      const constraints = {
        video: wantVideo ? {
          facingMode: facing,
          width: { ideal: 1280 }, height: { ideal: 720 },
          frameRate: { ideal: 30, max: 30 }
        } : false,
        audio: wantAudio ? { echoCancellation: true, noiseSuppression: true, autoGainControl: true } : false
      };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);

      const vt = stream.getVideoTracks()[0]; if (vt) vt.enabled = wantVideo;
      const at = stream.getAudioTracks()[0]; if (at) at.enabled = wantAudio;
      if (vt && 'contentHint' in vt) { try { vt.contentHint = 'motion'; } catch {} }
      return stream;
    }

    function applyVideoToggle() {
      if (!localStream) return;
      const vt = localStream.getVideoTracks()[0];
      if (vt) {
        vt.enabled = videoOn.checked;
        setStatus(videoOn.checked ? 'Video ON' : 'Video OFF');
        if (document.body.classList.contains('previewing')) {
          localVideo.style.display = videoOn.checked ? 'block' : 'none';
        }
      }
    }
    function applyAudioToggle() {
      if (!localStream) return;
      const at = localStream.getAudioTracks()[0];
      if (at) {
        at.enabled = audioOn.checked;
        setStatus(audioOn.checked ? 'Audio ON' : 'Audio OFF');
      }
    }
    videoOn.addEventListener('change', applyVideoToggle);
    audioOn.addEventListener('change', applyAudioToggle);

    // --- UI helpers ---
    function beginPreviewWindow(minutes) {
      const ms = Math.max(0, Math.round((Number(minutes) || 1) * 60000));
      if (ms === 0) { enterBlackout(); return; }

      document.body.classList.add('previewing','streaming');
      document.body.classList.remove('ui-visible');
      localVideo.style.display = videoOn.checked ? 'block' : 'none';

      previewEnd = Date.now() + ms;
      tickPreviewCountdown();
      previewTicker = setInterval(tickPreviewCountdown, 1000);
      previewTimer  = setTimeout(endPreviewNow, ms);
    }
    function tickPreviewCountdown() {
      const remain = Math.max(0, previewEnd - Date.now());
      const sec = Math.ceil(remain / 1000);
      const mm = String(Math.floor(sec / 60)).padStart(2,'0');
      const ss = String(sec % 60).padStart(2,'0');
      setStatus(`Preview ends in ${mm}:${ss}`);
    }
    function endPreviewNow() {
      if (previewTimer) clearTimeout(previewTimer);
      if (previewTicker) clearInterval(previewTicker);
      previewTimer = previewTicker = null;
      enterBlackout();
    }
    function enterBlackout() {
      document.body.classList.remove('previewing');
      document.body.classList.add('streaming');
      document.body.classList.remove('ui-visible');
      localVideo.style.display = 'none';
      setStatus('Streaming...');
      clearTimeout(hideUITimer); hideUITimer = null;
    }
    document.addEventListener('click', (e) => {
      if (document.body.classList.contains('previewing')) { endPreviewNow(); return; }
      if (document.body.classList.contains('streaming')) {
        if (document.body.classList.contains('ui-visible')) {
          const inCard = e.target.closest('.card');
          if (!inCard) { document.body.classList.remove('ui-visible'); setStatus('Streaming...'); clearTimeout(hideUITimer); }
        } else {
          document.body.classList.add('ui-visible'); setStatus('Streaming...');
          clearTimeout(hideUITimer);
          hideUITimer = setTimeout(() => { document.body.classList.remove('ui-visible'); setStatus('Streaming...'); }, UI_AUTOHIDE_MS);
        }
      }
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (document.body.classList.contains('previewing')) endPreviewNow();
        else if (document.body.classList.contains('streaming') && document.body.classList.contains('ui-visible')) {
          document.body.classList.remove('ui-visible'); setStatus('Streaming...');
          clearTimeout(hideUITimer); hideUITimer = null;
        }
      }
    });

    // --- WebSocket / signaling (targeted) ---
    function send(o){ try { ws?.readyState===WebSocket.OPEN && ws.send(JSON.stringify(o)); } catch {} }

    async function connectWS(room) {
      return new Promise((resolve, reject) => {
        const url = `${WS_ENDPOINT}?room=${encodeURIComponent(room)}`;
        setStatus('Connecting to signaling…');
        const sock = new WebSocket(url);
        ws = sock;

        let opened = false;
        const to = setTimeout(() => { if (!opened) { try{sock.close();}catch{}; setStatus('Signaling: timeout'); reject(new Error('WS timeout')); } }, 15000);

        sock.onopen = () => {
          opened = true; clearTimeout(to);
          setStatus('Signaling: connected');
          send({ type: 'join', room, role: 'sender' });
          resolve();
        };
        sock.onmessage = onSignal;
        sock.onerror = (e) => console.warn('[WS error]', e);
        sock.onclose  = () => setStatus('Signaling: closed');
      });
    }

    function createPeer(peerId) {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
        bundlePolicy: 'max-bundle',
        sdpSemantics: 'unified-plan'
      });
      // add current tracks
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.onicecandidate = (e) => { if (e.candidate) send({ type:'candidate', to: peerId, candidate: e.candidate }); };
      pc.oniceconnectionstatechange = () => { console.log(`[ICE ${peerId}]`, pc.iceConnectionState); };

      const entry = { pc, remoteDescriptionSet: false, candidateQueue: [], lastOfferSdp: null };
      peers.set(peerId, entry);
      return entry;
    }

    async function handleOffer(fromId, offer) {
      let entry = peers.get(fromId) || createPeer(fromId);
      const { pc, candidateQueue, lastOfferSdp } = entry;

      if (lastOfferSdp === offer.sdp) { console.log('[DUP] identical offer ignored from', fromId); return; }
      entry.lastOfferSdp = offer.sdp;

      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      entry.remoteDescriptionSet = true;

      while (candidateQueue.length) {
        const c = candidateQueue.shift();
        try { await pc.addIceCandidate(c); } catch (e) { console.warn('late ICE add failed', e); }
      }

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      send({ type: 'answer', to: fromId, sdp: answer.sdp });
    }

    async function handleCandidate(fromId, cand) {
      let entry = peers.get(fromId);
      if (!entry) entry = createPeer(fromId);
      const { remoteDescriptionSet, candidateQueue, pc } = entry;

      const ice = new RTCIceCandidate(cand);
      if (remoteDescriptionSet) {
        try { await pc.addIceCandidate(ice); } catch (e) { console.warn('ICE add failed', e); }
      } else {
        candidateQueue.push(ice);
      }
    }

    // CHANGED: do NOT stop local tracks here — only close that peer’s PC
    function handlePeerLeft(peerId) {
      const entry = peers.get(peerId);
      if (!entry) return;
      try { entry.pc.close(); } catch {}
      peers.delete(peerId);
      console.log('[INFO] receiver left', peerId, '(kept camera tracks live)');
    }

    async function onSignal(evt) {
      let msg; try { msg = JSON.parse(evt.data); } catch { return; }

      if (msg.type === 'hello') { myId = msg.id; return; }

      if (msg.type === 'offer' && msg.from) {
        setStatus('Got offer, creating answer…');
        await handleOffer(msg.from, msg);

      } else if (msg.type === 'candidate' && msg.from && msg.candidate) {
        await handleCandidate(msg.from, msg.candidate);

      } else if (msg.type === 'peer-left' && msg.id) {
        handlePeerLeft(msg.id);

      // NEW: also handle a receiver explicitly sending "bye"
      } else if (msg.type === 'bye' && msg.from) {
        handlePeerLeft(msg.from);
      }
    }

    async function startOrStop() {
      try {
        if (started) { await stopStreaming(); return; }

        startBtn.disabled = true;

        const room = currentRoom();
        setStatus('Starting camera…');
        localStream = await getMedia();
        localVideo.srcObject = localStream;
        applyVideoToggle(); applyAudioToggle();

        beginPreviewWindow(Number(previewMinsInput.value) || 1);
        await connectWS(room);

        started = true;
        startBtn.textContent = 'Stop streaming';
        startBtn.disabled = false;
      } catch (err) {
        console.error(err);
        alert(err.message || err);
        setStatus('Idle');
        startBtn.disabled = false;
      }
    }

    async function stopStreaming() {
      try { send({ type: 'bye' }); } catch {}

      if (previewTimer) clearTimeout(previewTimer);
      if (previewTicker) clearInterval(previewTicker);
      previewTimer = previewTicker = null;

      // CHANGED: just close each peer PC (do NOT stop local tracks here)
      for (const [peerId, entry] of peers) {
        try { entry.pc.close(); } catch {}
      }
      peers.clear();

      // Now stop the actual camera/mic tracks once (since the user is stopping)
      try { localStream && localStream.getTracks().forEach(t => t.stop()); } catch {}

      try { ws && ws.close(); } catch {}

      localStream = null; ws = null; started = false;

      document.body.classList.remove('previewing','streaming','ui-visible');
      document.body.classList.add('blackout');
      localVideo.style.display = 'none';
      setStatus('Stopped');

      startBtn.textContent = 'Start streaming';
    }

    window.addEventListener('beforeunload', stopStreaming);
    startBtn.addEventListener('click', startOrStop);
  </script>
</body>
</html>
