<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live Spectrogram with Blue MFCC</title>
  <script src="https://cdn.jsdelivr.net/npm/meyda/dist/web/meyda.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      background-color: white;
      color: #000;
    }

    canvas {
      border: 1px solid #666;
      display: block;
      margin-bottom: 30px;
      background-color: black;
    }

    label, select {
      margin-right: 10px;
    }

    .spectrogram-section {
      margin-top: 20px;
    }

    .title {
      margin-bottom: 5px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¤ Live Audio Spectrogram</h1>

  <label for="displayMode">Display Mode:</label>
  <select id="displayMode">
    <option value="single">Single Feature</option>
    <option value="all" selected>All Features</option>
  </select>

  <label for="feature">Single Feature:</label>
  <select id="feature" disabled>
    <option value="mfcc">MFCC (Perceptual)</option>
    <option value="amplitudeSpectrum">Amplitude Spectrum</option>
    <option value="powerSpectrum" selected>Power Spectrum</option>
  </select>

  <label for="colormap">Colormap:</label>
  <select id="colormap">
    <option value="grayscale">Grayscale</option>
    <option value="rainbow" selected>Rainbow (HSL)</option>
    <option value="heat">Heatmap</option>
  </select>

  <label for="bufferSize">Buffer Size:</label>
  <select id="bufferSize">
    <option value="256">256</option>
    <option value="512" selected>512</option>
    <option value="1024">1024</option>
    <option value="2048">2048</option>
  </select>

  <label for="hopSize">Hop Size:</label>
  <select id="hopSize">
    <option value="128">128</option>
    <option value="256" selected>256</option>
    <option value="512">512</option>
    <option value="1024">1024</option>
  </select>

  <button id="start">Start Microphone</button>

  <div id="spectrograms"></div>

  <script>
    const displayModeEl = document.getElementById('displayMode');
    const featureEl = document.getElementById('feature');
    const colormapEl = document.getElementById('colormap');
    const bufferSizeEl = document.getElementById('bufferSize');
    const hopSizeEl = document.getElementById('hopSize');
    const startButton = document.getElementById('start');
    const container = document.getElementById('spectrograms');

    const canvasWidth = 800;
    const canvasHeight = 256;
    const barWidth = 1;

    let audioCtx, meydaAnalyzers = {}, sources = {};
    let xPositions = {};
    let canvases = {};
    let contexts = {};

    const features = ['mfcc', 'amplitudeSpectrum', 'powerSpectrum'];

    function createCanvas(id, title) {
      const wrapper = document.createElement('div');
      wrapper.className = 'spectrogram-section';

      const label = document.createElement('div');
      label.className = 'title';
      label.innerText = title;

      const canvas = document.createElement('canvas');
      canvas.id = id;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      canvas.style.backgroundColor = 'black';

      wrapper.appendChild(label);
      wrapper.appendChild(canvas);
      container.appendChild(wrapper);

      return canvas;
    }

    function resetCanvas(ctx) {
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    }

    function drawFrame(ctx, x, spectrum, featureName, colormap) {
      const numBands = spectrum.length;

      if (x >= canvasWidth) {
        const imageData = ctx.getImageData(barWidth, 0, canvasWidth - barWidth, canvasHeight);
        ctx.putImageData(imageData, 0, 0);
        x = canvasWidth - barWidth;
        ctx.clearRect(x, 0, barWidth, canvasHeight);
      }

      for (let i = 0; i < numBands; i++) {
        const value = spectrum[i];
        let norm;

        if (featureName === 'mfcc') {
          norm = Math.min(1, Math.max(0, (value + 100) / 100));
        } else {
          norm = Math.min(1, Math.max(0, Math.log10(value + 1) / 3));
        }

        const intensity = Math.floor(norm * 255);
        const y = canvasHeight - (i / numBands) * canvasHeight;

        let color;

        if (featureName === 'mfcc') {
          // ðŸ”µ Shades of blue for MFCC
          color = `rgb(0, 0, ${intensity})`;
        } else {
          switch (colormap) {
            case 'grayscale':
              color = `rgb(${intensity}, ${intensity}, ${intensity})`;
              break;
            case 'rainbow':
              const hue = 240 - (intensity / 255) * 240;
              color = `hsl(${hue}, 100%, 50%)`;
              break;
            case 'heat':
              const r = intensity;
              const g = Math.floor(intensity * 0.2);
              const b = 255 - intensity;
              color = `rgb(${r}, ${g}, ${b})`;
              break;
          }
        }

        ctx.fillStyle = color;
        ctx.fillRect(x, y, barWidth, canvasHeight / numBands);
      }

      return x + barWidth;
    }

    displayModeEl.addEventListener('change', (e) => {
      const mode = e.target.value;
      featureEl.disabled = mode !== 'single';
    });

    startButton.addEventListener('click', async () => {
      const mode = displayModeEl.value;
      const selectedFeature = featureEl.value;
      const selectedColormap = colormapEl.value;
      const bufferSize = parseInt(bufferSizeEl.value);
      const hopSize = parseInt(hopSizeEl.value);

      container.innerHTML = '';
      xPositions = {};
      canvases = {};
      contexts = {};
      meydaAnalyzers = {};

      if (!audioCtx) {
        audioCtx = new AudioContext({ sampleRate: 16000 });
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        sources.stream = stream;
        sources.input = audioCtx.createMediaStreamSource(stream);
      }

      if (mode === 'single') {
        const canvas = createCanvas(`canvas-${selectedFeature}`, selectedFeature);
        canvases[selectedFeature] = canvas;
        contexts[selectedFeature] = canvas.getContext('2d');
        xPositions[selectedFeature] = 0;
        resetCanvas(contexts[selectedFeature]);

        const analyzer = Meyda.createMeydaAnalyzer({
          audioContext: audioCtx,
          source: sources.input,
          bufferSize: bufferSize,
          hopSize: hopSize,
          windowingFunction: 'hamming',
          featureExtractors: [selectedFeature],
          callback: (features) => {
            const spectrum = features[selectedFeature];
            if (spectrum) {
              xPositions[selectedFeature] = drawFrame(
                contexts[selectedFeature],
                xPositions[selectedFeature],
                spectrum,
                selectedFeature,
                selectedColormap
              );
            }
          }
        });

        meydaAnalyzers[selectedFeature] = analyzer;
        analyzer.start();
      } else {
        features.forEach((featureName) => {
          const canvas = createCanvas(`canvas-${featureName}`, featureName);
          canvases[featureName] = canvas;
          contexts[featureName] = canvas.getContext('2d');
          xPositions[featureName] = 0;
          resetCanvas(contexts[featureName]);

          const analyzer = Meyda.createMeydaAnalyzer({
            audioContext: audioCtx,
            source: sources.input,
            bufferSize: bufferSize,
            hopSize: hopSize,
            windowingFunction: 'hamming',
            featureExtractors: [featureName],
            callback: (features) => {
              const spectrum = features[featureName];
              if (spectrum) {
                xPositions[featureName] = drawFrame(
                  contexts[featureName],
                  xPositions[featureName],
                  spectrum,
                  featureName,
                  colormapEl.value
                );
              }
            }
          });

          meydaAnalyzers[featureName] = analyzer;
          analyzer.start();
        });
      }
    });
  </script>
</body>
</html>
